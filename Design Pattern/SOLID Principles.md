# SOLID Principles

> 로버트 C. 마틴이 명명한 객체지향 프로그래밍 및 설계의 기본원칙
> 프로그래머가 유지보수가 쉽고, 확장성이 있는 프로그램을 개발하려 할 때 이 원칙들을 적용할 수 있다.

### 1. SRP(Single Responsibility Principle)

- 단일 책임 원칙
- **한 객체는 단 하나의 책임**만을 가져야 한다.
- 객체 지향적으로 설계할 때는 **응집도는 높게, 결합도는 낮게**  설계
  - 응집도는 모듈 내부의 기능적인 응집 정도이고, 결합도는 모듈과 모듈간의 상호 결합 정도

- 객체에 책임이 많아질수록 객체 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합할 가능성이 높아진다.
  - 객체가 하는 일에 변경이 있을 떄에 해당 기능을 사용하는 부분을 모두 다시 테스트 해야하기 때문

> 하나의 객체가 단 하나의 일만 가지도록 분배하면 시스템에 변화가 생겨도 그 영향을 최소화 할 수 있다.



### 2. OCP(Open-Closed Principle)

- 개방-폐쇄 원칙
- **확장에 대해서는 개방적, 변경에 대해서는 폐쇄적**이어야 한다
- 기존 코드에 기능을 추가하되(open) 기존 코드는 변경하지 않는(close) 설계가 되어야 한다.
- 여러 객체에 사용하는 동일한 기능을 **인터페이스**에 정의하는 방법이 있다. => **캡슐화**

- 예시

  - Animal 인터페이스를 구현하는 Dog, Cat, Bird 클래스는 cry()를 재정의한다.
  - 이처럼 캡슐화를 하면, 동물이 추가되어도 cry()를 호출하는 부분은 수정하지 않아도 쉽게 확장할 수 있다.

  ![OCP](https://user-images.githubusercontent.com/50176238/107950873-bed33b00-6fda-11eb-94dd-076ab7e36918.PNG)

  - 클라이언트는 Animal에서 정의한 cry()를 호출하면 된다.

  ```java
  public class Client {
      public static void main(String args[]){
          Animal dog = new Dog();
          Animal cat = new Cat();
          
          dog.cry();
          cat.cry();
      }
  }
  ```

  

### 3. LSP(Liskov Substitution Principle)

- 리스코프 치환 원칙
- **자식 클래스는 최소한 부모 클래스에서 가능한 행위를 수행할 수 있어야** 한다.
- 자식 클래스는 부모 클래스의 역할을 대체할 수 있어야 한다.=> 클래스들의 행위는 일관된다.
- **자식 클래스는 부모 클래스의 책임을 무시하거나 재정의 하지 않고, 확장만 수행**한다.
- 오버라이드(재정의)는 가급적 피한다.



### 4. ISP(Interface Segregation Principle)

- 인터페이스 분리 원칙
- **클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야** 한다.
- 하나의 거대한 인터페이스보다 **여러 개의 구체적인 인터페이스가 낫다.**

> SRP가 객체의 단일 책임을 뜻한다면, ISP는 인터페이스의 단일 책임을 뜻한다.



### 5. DIP(Dependency Inversion Principle)

- 의존 역전 원칙
- **의존 관계는 변화하기 어렵거나 변화가 거의 없는 것과 맺어야** 한다.
- 객체들이 서로 정보를 주고 받을 때 의존 관계가 형성되는데, 이 때 객체들은 추상성이 낮은 클래스보다 **추상성이 높은 클래스와 의존관계를 맺어야** 한다
- 일반적으로 **인터페이스**를 활용하면 이 원칙을 준수할 수 있다.



### 참조

[[Design Pattern] SOLID 원칙 (SOLID Principles)](https://da-nyee.github.io/posts/design-pattern-solid-principles/)